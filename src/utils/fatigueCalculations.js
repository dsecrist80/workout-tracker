// utils/fatigueCalculations.js
// =====================================================
// Fatigue & Recovery Algorithm Implementation
// Exponential Model Based on Stimulus-Fatigue Dynamics
// =====================================================

import { FATIGUE_CONFIG } from '../constants/config';
import { MUSCLES } from '../constants/muscles';
import { isCompoundExercise } from '../constants/exerciseTypes';

/**
 * Estimate 1RM from a set using Epley formula
 * 1RM = weight × (1 + reps/30)
 * @param {number} weight - Weight lifted
 * @param {number} reps - Reps performed
 * @param {number} rir - RIR of the set
 * @returns {number} Estimated 1RM
 */
export function estimate1RM(weight, reps, rir = 0) {
  const totalRepsToFailure = reps + rir;
  
  if (FATIGUE_CONFIG.USE_EPLEY_FORMULA) {
    // Epley: 1RM = weight × (1 + reps/30)
    return weight * (1 + totalRepsToFailure / 30);
  } else {
    // Brzycki: 1RM = weight / (1.0278 - 0.0278 × reps)
    return weight / (1.0278 - 0.0278 * totalRepsToFailure);
  }
}

/**
 * Calculate stimulus generated by a single set for a specific muscle
 * Stimulus = exp(-k × RIR) × (Load/1RM) × RoleMultiplier
 * @param {Object} set - Set data {w, r, rir}
 * @param {string} muscle - Muscle name
 * @param {string} role - 'primary', 'secondary', or 'tertiary'
 * @param {number} estimated1RM - Estimated 1RM for the exercise
 * @returns {number} Stimulus value
 */
export function calculateStimulusPerSet(set, muscle, role, estimated1RM) {
  const { w, r, rir } = set;
  const k = FATIGUE_CONFIG.RIR_DECAY_CONSTANT;
  
  // Effort factor: exp(-k × RIR)
  // RIR 0 → 1.0 (maximal effort)
  // RIR 2 → ~0.55 (moderate effort)
  // RIR 4 → ~0.30 (light effort)
  const effortFactor = Math.exp(-k * rir);
  
  // Load factor: current weight / estimated 1RM
  // Higher loads = more stimulus
  const loadFactor = estimated1RM > 0 ? w / estimated1RM : 0.5;
  
  // Role multiplier
  const roleMultiplier = 
    role === 'primary' ? FATIGUE_CONFIG.PRIMARY_MUSCLE_MULTIPLIER :
    role === 'secondary' ? FATIGUE_CONFIG.SECONDARY_MUSCLE_MULTIPLIER :
    FATIGUE_CONFIG.TERTIARY_MUSCLE_MULTIPLIER;
  
  return effortFactor * loadFactor * roleMultiplier;
}

/**
 * Calculate local fatigue generated by a single set for a specific muscle
 * LocalFatigue = (Load × Reps) × RoleMultiplier × AxialMultiplier
 * @param {Object} set - Set data {w, r, rir}
 * @param {string} muscle - Muscle name
 * @param {string} role - 'primary', 'secondary', or 'tertiary'
 * @param {boolean} isAxial - Is exercise axially loaded
 * @returns {number} Local fatigue value
 */
export function calculateLocalFatiguePerSet(set, muscle, role, isAxial = false) {
  const { w, r } = set;
  
  // Base fatigue: Load × Reps
  const baseFatigue = w * r;
  
  // Role multiplier
  const roleMultiplier = 
    role === 'primary' ? FATIGUE_CONFIG.PRIMARY_MUSCLE_MULTIPLIER :
    role === 'secondary' ? FATIGUE_CONFIG.SECONDARY_MUSCLE_MULTIPLIER :
    FATIGUE_CONFIG.TERTIARY_MUSCLE_MULTIPLIER;
  
  // Axial multiplier (spine compression increases fatigue)
  const axialMultiplier = isAxial ? FATIGUE_CONFIG.AXIAL_LOAD_MULTIPLIER : 1.0;
  
  return baseFatigue * roleMultiplier * axialMultiplier;
}

/**
 * Calculate systemic fatigue generated by a single set
 * Only compound exercises generate systemic fatigue
 * SystemicFatigue = (Load × Reps) × AxialMultiplier × CompoundMultiplier
 * @param {Object} set - Set data {w, r, rir}
 * @param {string} exerciseType - Exercise type
 * @param {boolean} isAxial - Is exercise axially loaded
 * @returns {number} Systemic fatigue value
 */
export function calculateSystemicFatiguePerSet(set, exerciseType, isAxial = false) {
  const { w, r } = set;
  
  // Only compound exercises contribute to systemic fatigue
  if (!isCompoundExercise(exerciseType)) {
    return 0;
  }
  
  const baseFatigue = w * r;
  const axialMultiplier = isAxial ? FATIGUE_CONFIG.AXIAL_LOAD_MULTIPLIER : 1.0;
  const compoundMultiplier = FATIGUE_CONFIG.COMPOUND_SYSTEMIC_MULTIPLIER;
  
  return baseFatigue * axialMultiplier * compoundMultiplier;
}

/**
 * Calculate total stimulus and fatigue from a complete exercise
 * @param {Object} exercise - Exercise with sets, type, muscles, etc.
 * @returns {Object} Stimulus and fatigue metrics
 */
export function calculateExerciseMetrics(exercise) {
  const { sets, type, axial, prim = [], sec = [], ter = [] } = exercise;
  
  if (!sets || sets.length === 0) {
    return {
      stimulus: {},
      localFatigue: {},
      systemicFatigue: 0,
      setCount: 0
    };
  }
  
  // Estimate 1RM from best set (highest load factor)
  const topSet = sets.reduce((best, set) => 
    (set.w * set.r > best.w * best.r) ? set : best
  , sets[0]);
  const estimated1RM = estimate1RM(topSet.w, topSet.r, topSet.rir);
  
  const stimulus = {};
  const localFatigue = {};
  let systemicFatigue = 0;
  
  sets.forEach(set => {
    // Calculate for primary muscles
    prim.forEach(muscle => {
      stimulus[muscle] = (stimulus[muscle] || 0) + 
        calculateStimulusPerSet(set, muscle, 'primary', estimated1RM);
      localFatigue[muscle] = (localFatigue[muscle] || 0) + 
        calculateLocalFatiguePerSet(set, muscle, 'primary', axial);
    });
    
    // Calculate for secondary muscles
    sec.forEach(muscle => {
      stimulus[muscle] = (stimulus[muscle] || 0) + 
        calculateStimulusPerSet(set, muscle, 'secondary', estimated1RM);
      localFatigue[muscle] = (localFatigue[muscle] || 0) + 
        calculateLocalFatiguePerSet(set, muscle, 'secondary', axial);
    });
    
    // Calculate for tertiary muscles
    ter.forEach(muscle => {
      stimulus[muscle] = (stimulus[muscle] || 0) + 
        calculateStimulusPerSet(set, muscle, 'tertiary', estimated1RM);
      localFatigue[muscle] = (localFatigue[muscle] || 0) + 
        calculateLocalFatiguePerSet(set, muscle, 'tertiary', axial);
    });
    
    // Systemic fatigue
    systemicFatigue += calculateSystemicFatiguePerSet(set, type, axial);
  });
  
  return {
    stimulus,
    localFatigue,
    systemicFatigue,
    setCount: sets.length,
    estimated1RM
  };
}

/**
 * Apply observational corrections to fatigue
 * Adjusts fatigue based on actual performance vs. targets
 * @param {Object} fatigueState - Current fatigue state
 * @param {Object} corrections - Correction data {rirError, soreness, perceivedFatigue}
 * @returns {Object} Corrected fatigue state
 */
export function applyObservationalCorrections(fatigueState, corrections) {
  const { localFatigue = {}, systemicFatigue = 0 } = fatigueState;
  const { rirError = 0, soreness = {}, perceivedFatigue = 5 } = corrections;
  
  const correctedLocal = { ...localFatigue };
  let correctedSystemic = systemicFatigue;
  
  // RIR performance error correction
  // If actual RIR < target RIR, you went closer to failure than planned
  if (rirError < 0) {
    const penalty = Math.abs(rirError) * FATIGUE_CONFIG.RIR_MISS_FATIGUE_PENALTY;
    correctedSystemic += penalty;
    
    // Apply to all active muscles
    Object.keys(localFatigue).forEach(muscle => {
      correctedLocal[muscle] = (correctedLocal[muscle] || 0) + penalty;
    });
  }
  
  // Soreness correction (only if reported)
  Object.entries(soreness).forEach(([muscle, level]) => {
    if (level > 0) {
      const sorenessAdjustment = (level / 10) * FATIGUE_CONFIG.SORENESS_FATIGUE_WEIGHT;
      correctedLocal[muscle] = (correctedLocal[muscle] || 0) * (1 + sorenessAdjustment);
    }
  });
  
  // Perceived fatigue correction
  const perceptionDelta = perceivedFatigue - 5; // -5 to +5
  if (perceptionDelta !== 0) {
    const perceptionAdjustment = (perceptionDelta / 5) * FATIGUE_CONFIG.PERCEIVED_FATIGUE_WEIGHT;
    correctedSystemic *= (1 + perceptionAdjustment);
  }
  
  return {
    localFatigue: correctedLocal,
    systemicFatigue: correctedSystemic
  };
}

/**
 * Update fatigue and stimulus from a complete workout session
 * @param {Array} session - Array of exercises
 * @param {string} date - Workout date
 * @param {Object} currentState - Current fatigue/stimulus state
 * @param {Object} programContext - Optional program info {activeProgram, currentDayIndex, isRestDay}
 * @returns {Object} Updated state
 */
export function updateFatigueFromSession(session, date, currentState, programContext = null) {
  const {
    localFatigue = {},
    systemicFatigue = 0,
    weeklyStimulus = {},
    perceivedFatigue = 5,
    muscleSoreness = {},
    lastWorkoutDate = null
  } = currentState;
  
  // Handle rest day completion (no exercises)
  if (programContext?.isRestDay || (session.length === 0 && programContext)) {
    // Apply accelerated recovery for active rest day
    const restRecovery = calculateRecovery(
      { localFatigue, systemicFatigue },
      lastWorkoutDate || date,
      date,
      { plannedRestDays: 1 } // Bonus for following rest day
    );
    
    return {
      localFatigue: restRecovery.localFatigue,
      systemicFatigue: restRecovery.systemicFatigue,
      weeklyStimulus,
      sessionStimulus: {},
      muscleReadiness: calculateMuscleReadiness(restRecovery.localFatigue),
      systemicReadiness: calculateSystemicReadiness(restRecovery.systemicFatigue),
      lastWorkoutDate: lastWorkoutDate, // Don't update on rest day
      isRestDay: true
    };
  }
  
  // Step 1: Calculate recovery since last workout
  // Account for planned rest days if in a program
  let plannedRestDays = 0;
  if (programContext?.activeProgram && lastWorkoutDate) {
    plannedRestDays = countRestDaysBetween(
      programContext.activeProgram,
      programContext.lastDayIndex || 0,
      programContext.currentDayIndex || 0
    );
  }
  
  const recoveredState = calculateRecovery(
    { localFatigue, systemicFatigue },
    lastWorkoutDate,
    date,
    { plannedRestDays }
  );
  
  const newLocalFatigue = { ...recoveredState.localFatigue };
  let newSystemicFatigue = recoveredState.systemicFatigue;
  const newWeeklyStimulus = { ...weeklyStimulus };
  const sessionStimulus = {};
  
  // Step 2: Process each exercise in the session
  session.forEach(exercise => {
    const metrics = calculateExerciseMetrics(exercise);
    
    // Accumulate stimulus
    Object.entries(metrics.stimulus).forEach(([muscle, stim]) => {
      sessionStimulus[muscle] = (sessionStimulus[muscle] || 0) + stim;
      newWeeklyStimulus[muscle] = (newWeeklyStimulus[muscle] || 0) + stim;
    });
    
    // Accumulate fatigue
    Object.entries(metrics.localFatigue).forEach(([muscle, fatigue]) => {
      newLocalFatigue[muscle] = (newLocalFatigue[muscle] || 0) + fatigue;
    });
    
    newSystemicFatigue += metrics.systemicFatigue;
  });
  
  // Step 3: Apply observational corrections
  const corrected = applyObservationalCorrections(
    { localFatigue: newLocalFatigue, systemicFatigue: newSystemicFatigue },
    { rirError: 0, soreness: muscleSoreness, perceivedFatigue }
  );
  
  // Step 4: Normalize fatigue values to logarithmic scale
  const normalizedLocal = {};
  Object.entries(corrected.localFatigue).forEach(([muscle, fatigue]) => {
    normalizedLocal[muscle] = Math.log1p(fatigue / 1000);
  });
  
  const normalizedSystemic = Math.log1p(corrected.systemicFatigue / 1000);
  
  // Step 5: Calculate readiness scores
  const muscleReadiness = calculateMuscleReadiness(normalizedLocal);
  const systemicReadiness = calculateSystemicReadiness(normalizedSystemic);
  
  return {
    localFatigue: normalizedLocal,
    systemicFatigue: normalizedSystemic,
    weeklyStimulus: newWeeklyStimulus,
    sessionStimulus,
    muscleReadiness,
    systemicReadiness,
    lastWorkoutDate: date,
    restBonus: recoveredState.restBonus,
    isRestDay: false
  };
}

/**
 * Count actual rest days between two dates based on workout history
 * Any day without logged exercises counts as a rest day
 * @param {Array} workouts - Workout history
 * @param {string} startDate - Start date
 * @param {string} endDate - End date
 * @returns {number} Number of rest days
 */
export function countActualRestDays(workouts, startDate, endDate) {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const totalDays = getDaysBetween(startDate, endDate);
  
  if (totalDays <= 0) return 0;
  
  // Get unique workout dates in the range
  const workoutDates = new Set(
    workouts
      .filter(w => {
        const wDate = new Date(w.date);
        return wDate > start && wDate <= end;
      })
      .map(w => w.date)
  );
  
  // Rest days = total days - training days
  return totalDays - workoutDates.size;
}

/**
 * Count rest days between two program day indices
 * @param {Object} program - Active program
 * @param {number} startIndex - Starting day index
 * @param {number} endIndex - Ending day index
 * @returns {number} Number of rest days
 */
function countRestDaysBetween(program, startIndex, endIndex) {
  if (!program || !program.days) return 0;
  
  let count = 0;
  let current = startIndex;
  
  while (current !== endIndex) {
    current = (current + 1) % program.days.length;
    if (current === endIndex) break;
    
    if (program.days[current]?.isRestDay) {
      count++;
    }
  }
  
  return count;
}

/**
 * Calculate recovery over time using exponential decay
 * Accounts for planned rest days in programs
 * fatigue(t) = fatigue(0) × exp(-rate × days × restBonus)
 * @param {Object} fatigueState - Current fatigue levels
 * @param {string} lastWorkoutDate - Date of last workout
 * @param {string} currentDate - Current date
 * @param {Object} programContext - Optional program rest day info
 * @returns {Object} Recovered fatigue state
 */
export function calculateRecovery(fatigueState, lastWorkoutDate, currentDate, programContext = null) {
  if (!lastWorkoutDate) {
    return fatigueState;
  }
  
  const daysSinceLastWorkout = getDaysBetween(lastWorkoutDate, currentDate);
  
  if (daysSinceLastWorkout <= 0) {
    return fatigueState;
  }
  
  const { localFatigue = {}, systemicFatigue = 0 } = fatigueState;
  
  // Calculate recovery bonus from planned rest days
  let restBonus = 1.0;
  if (programContext && programContext.plannedRestDays > 0) {
    // 10% faster recovery per planned rest day (up to 50% faster)
    restBonus = 1 + Math.min(0.5, programContext.plannedRestDays * 0.1);
  }
  
  // Exponential recovery: fatigue × exp(-rate × days × restBonus)
  const localRate = FATIGUE_CONFIG.LOCAL_RECOVERY_RATE * restBonus;
  const systemicRate = FATIGUE_CONFIG.SYSTEMIC_RECOVERY_RATE * restBonus;
  
  const recoveredLocal = {};
  Object.entries(localFatigue).forEach(([muscle, fatigue]) => {
    recoveredLocal[muscle] = Math.max(0, fatigue * Math.exp(-localRate * daysSinceLastWorkout));
  });
  
  const recoveredSystemic = Math.max(0, systemicFatigue * Math.exp(-systemicRate * daysSinceLastWorkout));
  
  return {
    localFatigue: recoveredLocal,
    systemicFatigue: recoveredSystemic,
    restBonus // Return for tracking
  };
}

/**
 * Calculate muscle readiness from fatigue levels
 * Readiness = exp(-fatigue)
 * @param {Object} localFatigue - Local muscle fatigue object
 * @returns {Object} Muscle readiness scores (0-1)
 */
export function calculateMuscleReadiness(localFatigue) {
  const readiness = {};
  
  MUSCLES.forEach(muscle => {
    const fatigue = localFatigue[muscle] || 0;
    // Exponential readiness function
    readiness[muscle] = Math.exp(-fatigue);
  });
  
  return readiness;
}

/**
 * Calculate systemic readiness from systemic fatigue
 * Readiness = exp(-fatigue)
 * @param {number} systemicFatigue - Systemic fatigue level
 * @returns {number} Readiness score (0-1)
 */
export function calculateSystemicReadiness(systemicFatigue) {
  return Math.exp(-systemicFatigue);
}

/**
 * Decay weekly stimulus over time
 * @param {Object} weeklyStimulus - Current weekly stimulus
 * @param {number} days - Days since last update
 * @returns {Object} Decayed weekly stimulus
 */
export function decayWeeklyStimulus(weeklyStimulus, days) {
  const decayed = {};
  const rate = FATIGUE_CONFIG.STIMULUS_DECAY_RATE;
  
  Object.entries(weeklyStimulus).forEach(([muscle, stimulus]) => {
    decayed[muscle] = Math.max(0, stimulus * Math.exp(-rate * days));
  });
  
  return decayed;
}

/**
 * Check if deload is needed based on multi-day trends
 * Triggers when 2+ conditions persist for 7+ days
 * @param {Object} muscleReadiness - Muscle readiness object
 * @param {number} systemicReadiness - Systemic readiness
 * @param {Object} trends - Historical trend data
 * @returns {Object} Deload recommendation
 */
export function checkDeloadNeeded(muscleReadiness, systemicReadiness, trends = {}) {
  const threshold = FATIGUE_CONFIG.DELOAD_THRESHOLD;
  
  // Immediate systemic deload (no trend needed)
  // Changed from 0.5 to 0.35 - only trigger "critical" at very low readiness
  if (systemicReadiness < 0.35) {
    return {
      needed: true,
      type: 'systemic',
      severity: 'high',
      message: 'Systemic fatigue is critically high - immediate deload needed',
      recommendation: 'Reduce volume 40-60%, increase RIR by 2-3, remove axial loads'
    };
  }
  
  // Check for systemic deload with trend
  if (systemicReadiness < threshold) {
    return {
      needed: true,
      type: 'systemic',
      severity: 'moderate',
      message: 'Systemic deload needed - reduce overall training volume',
      recommendation: 'Reduce sets by 40%, increase RIR by 2, lighter axial loads'
    };
  }
  
  // Check local muscles
  const lowReadinessMuscles = Object.entries(muscleReadiness)
    .filter(([_, readiness]) => readiness < threshold)
    .map(([muscle, readiness]) => ({ muscle, readiness }));
  
  if (lowReadinessMuscles.length > 0) {
    return {
      needed: true,
      type: 'local',
      severity: lowReadinessMuscles.length > 3 ? 'high' : 'moderate',
      muscles: lowReadinessMuscles,
      message: `Local deload needed for: ${lowReadinessMuscles.map(m => m.muscle).join(', ')}`,
      recommendation: 'Reduce volume 30-40% for affected muscles, add 1-2 RIR'
    };
  }
  
  return {
    needed: false,
    type: null,
    severity: 'none',
    message: 'Recovery is adequate'
  };
}

/**
 * Get days between two dates
 */
function getDaysBetween(date1, date2) {
  const d1 = new Date(date1);
  const d2 = new Date(date2);
  const diffTime = Math.abs(d2 - d1);
  return Math.floor(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Calculate stimulus efficiency (stimulus per unit fatigue)
 * @param {Object} stimulus - Stimulus values per muscle
 * @param {Object} fatigue - Fatigue values per muscle
 * @returns {Object} Efficiency ratios
 */
export function calculateStimulusEfficiency(stimulus, fatigue) {
  const efficiency = {};
  
  Object.keys(stimulus).forEach(muscle => {
    const stim = stimulus[muscle] || 0;
    const fat = fatigue[muscle] || 0.001; // Avoid division by zero
    efficiency[muscle] = stim / fat;
  });
  
  return efficiency;
}

/**
 * Detect if stimulus is stagnant despite adequate recovery
 * @param {Array} weeklyStimulus - Array of weekly stimulus values
 * @param {number} readiness - Current readiness
 * @returns {boolean} True if stagnant
 */
export function detectStimulusStagnation(weeklyStimulus, readiness) {
  if (weeklyStimulus.length < 3) return false;
  
  // Check if stimulus is flat or declining over 3+ weeks
  const recent = weeklyStimulus.slice(-3);
  const isFlat = recent.every((val, i, arr) => 
    i === 0 || Math.abs(val - arr[i-1]) < 0.1
  );
  const isDecreasing = recent.every((val, i, arr) => 
    i === 0 || val <= arr[i-1]
  );
  
  // If readiness is good but stimulus is stagnant, time to increase volume
  return (isFlat || isDecreasing) && readiness > 0.85;
}